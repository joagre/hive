.\" Man page for TCP functions
.TH HIVE_TCP 3 "January 2026" "Hive 1.0" "Actor Runtime Manual"
.SH NAME
hive_tcp_listen, hive_tcp_accept, hive_tcp_connect, hive_tcp_close, hive_tcp_recv, hive_tcp_send \- non-blocking TCP
.SH SYNOPSIS
.nf
.B #include <hive_tcp.h>
.PP
.BI "hive_status_t hive_tcp_listen(uint16_t " port ", int *" out ");"
.BI "hive_status_t hive_tcp_accept(int " listen_fd ", int *" out ", int32_t " timeout_ms ");"
.BI "hive_status_t hive_tcp_connect(const char *" ip ", uint16_t " port ", int *" out ", int32_t " timeout_ms ");"
.BI "hive_status_t hive_tcp_close(int " fd ");"
.BI "hive_status_t hive_tcp_recv(int " fd ", void *" buf ", size_t " len ", size_t *" bytes_read ", int32_t " timeout_ms ");"
.BI "hive_status_t hive_tcp_send(int " fd ", const void *" buf ", size_t " len ", size_t *" bytes_written ", int32_t " timeout_ms ");"
.fi
.SH DESCRIPTION
These functions provide non-blocking TCP for actors. All operations
integrate with the runtime's event loop (epoll on Linux),
allowing other actors to run while waiting for TCP events.
.PP
.B Note:
TCP is currently only available on Linux. STM32 support is not yet implemented.
.SS Server Operations
.BR hive_tcp_listen ()
creates a listening socket bound to
.I port
on all interfaces (INADDR_ANY). The socket is configured non-blocking with
SO_REUSEADDR. The socket descriptor is stored in
.IR out .
This operation does not block.
.PP
.BR hive_tcp_accept ()
accepts an incoming connection on
.IR listen_fd .
The new connection socket is stored in
.IR out .
If no connection is immediately available, the actor blocks until a connection
arrives or timeout expires.
.SS Client Operations
.BR hive_tcp_connect ()
establishes a TCP connection to
.I ip
(numeric IPv4 address) on
.IR port .
DNS resolution is
.B not supported
because it would block the scheduler. The connected socket is stored in
.IR out .
.SS Data Transfer
.BR hive_tcp_recv ()
receives up to
.I len
bytes into
.IR buf .
The actual number of bytes received is stored in
.IR bytes_read .
Returns 0 bytes on connection close (EOF).
.PP
.BR hive_tcp_send ()
sends up to
.I len
bytes from
.IR buf .
The actual number of bytes sent is stored in
.IR bytes_written .
Note: May send fewer bytes than requested (partial write); caller must retry with
remaining data.
.SS Closing
.BR hive_tcp_close ()
closes the socket. This is synchronous and does not block.
.SS Timeout Behavior
The
.I timeout_ms
parameter controls blocking for accept, connect, recv, and send:
.TP
.B HIVE_TIMEOUT_NONBLOCKING (0)
Return immediately with
.B HIVE_ERR_WOULDBLOCK
if operation would block.
.TP
.B HIVE_TIMEOUT_INFINITE (-1)
Block forever until operation completes.
.TP
.B positive value
Block up to the specified milliseconds, return
.B HIVE_ERR_TIMEOUT
if exceeded.
.SH RETURN VALUE
All functions return an
.I hive_status_t
structure. On success,
.I status.code
is
.BR HIVE_OK .
For
.BR hive_tcp_recv ()
returning 0 bytes received indicates the peer closed the connection (EOF).
.SH ERRORS
.TP
.B HIVE_ERR_INVALID
NULL argument, invalid IP address format (must be numeric IPv4), or not called
from actor context (for blocking operations).
.TP
.B HIVE_ERR_IO
Socket error (errno-based message: "Connection refused", "Address in use", etc.).
.TP
.B HIVE_ERR_WOULDBLOCK
Operation would block and timeout was 0.
.TP
.B HIVE_ERR_TIMEOUT
Operation did not complete within timeout period.
.TP
.B HIVE_ERR_NOMEM
I/O source pool exhausted (HIVE_IO_SOURCE_POOL_SIZE).
.SH NOTES
.SS Minimal by Design
The TCP API is intentionally minimal. It provides only the core operations needed
for actor-based TCP communication: listen, accept, connect, close, recv, send.
.PP
This is
.B not
a full BSD socket replacement. The following are intentionally omitted:
.IP \(bu 2
SSL/TLS (use a dedicated TLS library with I/O actors)
.IP \(bu 2
UDP/multicast (different I/O patterns, may be added later)
.IP \(bu 2
Socket options (SO_REUSEADDR is set automatically; others require HAL extension)
.IP \(bu 2
Scatter/gather I/O (use multiple send/recv calls)
.IP \(bu 2
Out-of-band data
.PP
For advanced networking requirements, extend the HAL or use external libraries
with dedicated I/O actors.
.SS No DNS Resolution
.BR hive_tcp_connect ()
requires numeric IPv4 addresses (e.g., "192.168.1.1"). Hostnames are
.B not supported
because DNS resolution is blocking and would stall the scheduler. Resolve
hostnames before calling, or use static IP addresses.
.SS Non-Blocking Integration
All blocking TCP operations use the scheduler's epoll event loop. While an
actor waits for TCP, other actors continue running. This is cooperative:
the waiting actor yields automatically.
.SS Partial Reads/Writes
.BR hive_tcp_recv ()
and
.BR hive_tcp_send ()
may transfer fewer bytes than requested. Always check the
.I bytes_read
or
.I bytes_written
output parameter and loop to transfer remaining data:
.PP
.nf
size_t total_sent = 0;
while (total_sent < len) {
    size_t n;
    hive_status_t s = hive_tcp_send(fd, buf + total_sent,
                                  len - total_sent, &n, 5000);
    if (HIVE_FAILED(s)) break;
    total_sent += n;
}
.fi
.SS Connection Close Detection
.BR hive_tcp_recv ()
returns success with
.I *bytes_read = 0
when the peer closes the connection. This is normal EOF, not an error:
.PP
.nf
size_t n;
hive_status_t s = hive_tcp_recv(fd, buf, sizeof(buf), &n, -1);
if (HIVE_SUCCEEDED(s) && n == 0) {
    /* Peer closed connection */
}
.fi
.SS Socket Lifecycle
Sockets from
.BR hive_tcp_listen (),
.BR hive_tcp_accept (),
and
.BR hive_tcp_connect ()
are non-blocking file descriptors. The caller is responsible for closing them
with
.BR hive_tcp_close ()
when done.
.SS Pool Limits
TCP operations use the I/O source pool (HIVE_IO_SOURCE_POOL_SIZE, default 64).
Each pending blocking operation consumes one entry. If exhausted,
.B HIVE_ERR_NOMEM
is returned.
.SS Embedded Considerations
.IP \(bu 2
.B Linux:
Non-blocking sockets with epoll integration
.IP \(bu 2
.B STM32:
Not yet implemented
.IP \(bu 2
Zero heap allocation in I/O operations
.IP \(bu 2
O(1) epoll registration/deregistration
.IP \(bu 2
Suitable for telemetry, ground station links, and protocol handlers
.SS Safety-Critical Note
TCP has unbounded latency. For flight-critical systems:
.IP \(bu 2
Use timeouts to bound worst-case blocking
.IP \(bu 2
Run TCP actors at lower priority than control loops
.IP \(bu 2
Design for network failures (disconnection, latency spikes)
.SH EXAMPLE
.SS Echo Server
.nf
#include <hive_runtime.h>
#include <hive_tcp.h>
#include <stdio.h>
#include <string.h>

void client_handler(void *arg, const hive_spawn_info_t *siblings,
                    size_t sibling_count) {
    int conn_fd = *(int *)arg;
    char buf[256];

    while (1) {
        size_t n;
        hive_status_t s = hive_tcp_recv(conn_fd, buf, sizeof(buf), &n, 5000);
        if (HIVE_FAILED(s)) {
            printf("Recv error: %s\\n", HIVE_ERR_STR(s));
            break;
        }
        if (n == 0) {
            printf("Client disconnected\\n");
            break;
        }

        /* Echo back */
        size_t sent = 0;
        while (sent < n) {
            size_t s_n;
            hive_status_t ss = hive_tcp_send(conn_fd, buf + sent, n - sent, &s_n, 5000);
            if (HIVE_FAILED(ss)) break;
            sent += s_n;
        }
    }

    hive_tcp_close(conn_fd);
    hive_exit();
}

void server(void *arg, const hive_spawn_info_t *siblings,
            size_t sibling_count) {
    int listen_fd;

    hive_status_t s = hive_tcp_listen(8080, &listen_fd);
    if (HIVE_FAILED(s)) {
        printf("Listen failed: %s\\n", HIVE_ERR_STR(s));
        hive_exit();
    }

    printf("Server listening on port 8080\\n");

    while (1) {
        int conn_fd;
        s = hive_tcp_accept(listen_fd, &conn_fd, -1);
        if (HIVE_FAILED(s)) {
            printf("Accept failed: %s\\n", HIVE_ERR_STR(s));
            continue;
        }

        printf("Client connected\\n");

        /* Spawn handler actor for this connection */
        actor_id_t handler;
        hive_spawn(client_handler, NULL, &conn_fd, NULL, &handler);
    }
}

int main(void) {
    hive_init();
    actor_id_t srv;
    hive_spawn(server, NULL, NULL, NULL, &srv);
    hive_run();
    hive_cleanup();
    return 0;
}
.fi
.SS Client with Timeout
.nf
void client(void *arg, const hive_spawn_info_t *siblings,
            size_t sibling_count) {
    int fd;

    /* Connect with 5 second timeout */
    hive_status_t s = hive_tcp_connect("127.0.0.1", 8080, &fd, 5000);
    if (HIVE_FAILED(s)) {
        printf("Connect failed: %s\\n", HIVE_ERR_STR(s));
        hive_exit();
    }

    /* Send request */
    const char *msg = "Hello, server!";
    size_t sent;
    s = hive_tcp_send(fd, msg, strlen(msg), &sent, 1000);
    if (HIVE_FAILED(s)) {
        printf("Send failed: %s\\n", HIVE_ERR_STR(s));
    }

    /* Receive response */
    char buf[256];
    size_t n;
    s = hive_tcp_recv(fd, buf, sizeof(buf) - 1, &n, 1000);
    if (HIVE_SUCCEEDED(s) && n > 0) {
        buf[n] = '\\0';
        printf("Response: %s\\n", buf);
    }

    hive_tcp_close(fd);
    hive_exit();
}
.fi
.SH SEE ALSO
.BR hive_file (3),
.BR hive_timer (3),
.BR hive_spawn (3),
.BR socket (2),
.BR epoll (7)
