.\" Man page for IPC functions
.TH HIVE_IPC 3 "January 2026" "Hive 1.0" "Actor Runtime Manual"
.SH NAME
hive_ipc_notify, hive_ipc_notify_ex, hive_ipc_recv, hive_ipc_recv_match, hive_ipc_request, hive_ipc_reply, hive_ipc_named_notify, hive_ipc_named_request, hive_msg_is_timer, hive_ipc_pending, hive_ipc_count, hive_pool_set_block, hive_pool_get_block \- inter-process communication
.SH SYNOPSIS
.nf
.B #include <hive_ipc.h>
.PP
.BI "hive_status_t hive_ipc_notify(hive_actor_id_t " to ", uint16_t " id ", const void *" data ", size_t " len ");"
.BI "hive_status_t hive_ipc_notify_ex(hive_actor_id_t " to ", hive_msg_class_t " class ", uint16_t " id ","
.BI "                               const void *" data ", size_t " len ");"
.BI "hive_status_t hive_ipc_recv(hive_message_t *" msg ", int32_t " timeout_ms ");"
.BI "hive_status_t hive_ipc_recv_match(hive_actor_id_t " from ", hive_msg_class_t " class ","
.BI "                            uint16_t " id ", hive_message_t *" msg ", int32_t " timeout_ms ");"
.BI "hive_status_t hive_ipc_request(hive_actor_id_t " to ", uint16_t " id ", const void *" request ", size_t " req_len ","
.BI "                         hive_message_t *" reply ", int32_t " timeout_ms ");"
.BI "hive_status_t hive_ipc_reply(const hive_message_t *" request ", const void *" data ", size_t " len ");"
.BI "hive_status_t hive_ipc_named_notify(const char *" name ", uint16_t " id ","
.BI "                               const void *" data ", size_t " len ");"
.BI "hive_status_t hive_ipc_named_request(const char *" name ", uint16_t " id ", const void *" request ","
.BI "                               size_t " req_len ", hive_message_t *" reply ", int32_t " timeout_ms ");"
.BI "bool hive_msg_is_timer(const hive_message_t *" msg ");"
.BI "bool hive_ipc_pending(void);"
.BI "size_t hive_ipc_count(void);"
.PP
.B #include <hive_runtime.h>
.PP
.BI "void hive_pool_set_block(hive_pool_block_t " mode ");"
.BI "bool hive_pool_get_block(void);"
.fi
.SH DESCRIPTION
These functions implement message passing between actors. Each actor has one
mailbox. Messages are asynchronous by default (fire-and-forget).
.SS Message Structure
Messages received via
.BR hive_ipc_recv ()
are stored in the
.I hive_message_t
structure:
.PP
.nf
typedef struct {
    hive_actor_id_t  sender;  /* Sender actor ID */
    hive_msg_class_t class;   /* Message class */
    uint16_t         id;      /* Message type (user-defined) */
    uint32_t         tag;     /* Correlation tag (for request/reply) */
    size_t           len;     /* Payload length in bytes */
    const void      *data;    /* Payload pointer */
} hive_message_t;
.fi
.PP
The
.I id
field is the message type for dispatch (user-defined application values).
The
.I tag
field is for request/reply correlation (runtime-generated, used internally).
Access payload directly via cast:
.I my_type *p = (my_type *)msg.data;
.SS Message Classes
.TP
.B HIVE_MSG_NOTIFY
Fire-and-forget notification (sent via
.BR hive_ipc_notify ())
.TP
.B HIVE_MSG_REQUEST
Request expecting reply (sent via
.BR hive_ipc_request ())
.TP
.B HIVE_MSG_REPLY
Reply to request (sent via
.BR hive_ipc_reply ())
.TP
.B HIVE_MSG_TIMER
Timer tick (sent by runtime, see
.BR hive_timer (3))
.TP
.B HIVE_MSG_EXIT
Actor death notification (see
.BR hive_link (3))
.SS Notifying
.BR hive_ipc_notify ()
delivers an asynchronous message to actor
.IR to
with the specified message type
.IR id .
The
.I id
parameter is a user-defined value for message type dispatch on the receiver
side (see
.BR hive_ipc_recv_match ()).
The payload
.I data
of length
.I len
is copied to the receiver's mailbox. The sender continues immediately without
waiting. Maximum payload size is
.B HIVE_MAX_MESSAGE_SIZE - 6
(250 bytes by default).
.PP
.BR hive_ipc_notify_ex ()
is like
.BR hive_ipc_notify ()
but allows specifying the message
.I class
and
.IR id .
This is useful for implementing custom protocols where the receiver needs to
distinguish between different message types. The sender is automatically set to
the current actor.
.SS Receiving Messages
.BR hive_ipc_recv ()
receives the next message from the mailbox in FIFO order. The
.I timeout_ms
parameter controls blocking behavior:
.TP
.B HIVE_TIMEOUT_NONBLOCKING (0)
Return immediately with
.B HIVE_ERR_WOULDBLOCK
if mailbox is empty.
.TP
.B HIVE_TIMEOUT_INFINITE (-1)
Block forever until a message arrives.
.TP
.B positive value
Block up to the specified milliseconds, return
.B HIVE_ERR_TIMEOUT
if exceeded.
.PP
.BR hive_ipc_recv_match ()
performs selective receive, scanning the mailbox for a message matching all
specified filter criteria. Use the wildcard constants (all are 0) to match any
value:
.IP \(bu 2
.B HIVE_SENDER_ANY
\- match any sender
.IP \(bu 2
.B HIVE_MSG_ANY
\- match any message class
.IP \(bu 2
.B HIVE_ID_ANY
\- match any message id
.PP
Non-matching messages are skipped but remain in the mailbox. This operation is
.B O(n)
where n is the mailbox depth.
.PP
For multi-pattern receive (waiting on multiple IPC filters, bus sources, or HAL
events simultaneously), use
.BR hive_select (3).
.SS Request/Reply Pattern
.BR hive_ipc_request ()
issues a request and blocks until a reply is received, the target dies, or
timeout expires. It:
.IP 1. 3
Sets up a temporary monitor on the target to detect death
.IP 2. 3
Generates a unique tag
.IP 3. 3
Dispatches message with class
.B HIVE_MSG_REQUEST
.IP 4. 3
Waits for either
.B HIVE_MSG_REPLY
with matching tag (success) or
.B HIVE_MSG_EXIT
from the monitor (target died)
.IP 5. 3
Cleans up the monitor and returns the reply, error, or
.B HIVE_ERR_CLOSED
if target died
.PP
.BR hive_ipc_reply ()
dispatches a reply to a received request. It extracts the sender and tag from
.I request
automatically. The
.I request
parameter must be the message received via
.BR hive_ipc_recv ().
See
.B EXAMPLE
below for a complete request/reply server and client.
.SS Named IPC
Named IPC functions resolve actor names to IDs automatically, providing a
convenient way to notify or request named actors without manual
.BR hive_whereis (3)
calls.
.PP
.BR hive_ipc_named_notify ()
resolves
.I name
via
.BR hive_whereis (),
then notifies the resolved actor. Returns
.B HIVE_ERR_NOT_FOUND
if the name is not registered. Otherwise behaves identically to
.BR hive_ipc_notify ().
.PP
.BR hive_ipc_named_request ()
resolves
.I name
via
.BR hive_whereis (),
then issues a request and waits for a reply. Returns
.B HIVE_ERR_NOT_FOUND
if the name is not registered. Otherwise behaves identically to
.BR hive_ipc_request ().
.PP
These functions are useful when interacting with actors that may be restarted
by supervisors. Since actor IDs change on restart, caching IDs is unsafe. Named
IPC re-resolves the name on each call, ensuring messages reach the current
incarnation of the actor.
.PP
Example:
.PP
.nf
/* Notify named actor */
hive_ipc_named_notify("logger", LOG_MSG, &log_entry, sizeof(log_entry));

/* Request/reply with named actor */
hive_message_t reply;
hive_status_t s = hive_ipc_named_request("config_server", &req,
                                        sizeof(req), &reply, 5000);
if (s.code == HIVE_ERR_NOT_FOUND) {
    /* Actor not registered (not started or crashed) */
}
.fi
.SS Message Inspection
.BR hive_msg_is_timer ()
returns true if
.I msg
is a timer tick message (class =
.BR HIVE_MSG_TIMER ).
.PP
.BR hive_ipc_pending ()
returns true if the mailbox contains at least one message.
.PP
.BR hive_ipc_count ()
returns the number of messages in the mailbox.
.SH RETURN VALUE
Functions returning
.I hive_status_t
indicate success when
.I status.code
is
.BR HIVE_OK .
.PP
.BR hive_msg_is_timer ()
returns true for timer messages, false otherwise.
.PP
.BR hive_ipc_pending ()
returns true if messages are available.
.PP
.BR hive_ipc_count ()
returns the message count.
.SH ERRORS
.TP
.B HIVE_ERR_NOMEM
IPC pool exhausted (mailbox entry pool or message data pool). Notify/request does
.B not
block or drop messages; caller must handle this error.
.TP
.B HIVE_ERR_INVALID
Invalid actor ID, NULL data with non-zero length, or not called from actor
context.
.TP
.B HIVE_ERR_TIMEOUT
No message received within timeout period.
.TP
.B HIVE_ERR_CLOSED
Target actor died during
.BR hive_ipc_request ().
The request was issued but the target exited before replying.
.TP
.B HIVE_ERR_WOULDBLOCK
Mailbox empty and timeout was
.BR HIVE_TIMEOUT_NONBLOCKING .
.TP
.B HIVE_ERR_NOT_FOUND
Actor name not registered in name registry (named IPC functions only).
.SH NOTES
.SS Message Lifetime (Critical)
.B "Payload data is only valid until the next successful hive_ipc_recv() call."
Each actor has exactly one "current message" buffer. A new successful receive
overwrites the previous message data. Copy data immediately if needed later:
.PP
.nf
/* CORRECT */
hive_message_t msg;
hive_ipc_recv(&msg, -1);
my_data copy = *(my_data *)msg.data;  /* Copy immediately */
hive_ipc_recv(&msg, -1);              /* Previous data now invalid */
use_data(&copy);                       /* Use the copy */

/* WRONG - use-after-free */
hive_message_t msg;
hive_ipc_recv(&msg, -1);
my_data *ptr = (my_data *)msg.data;   /* Pointer to buffer */
hive_ipc_recv(&msg, -1);              /* Buffer overwritten! */
use_data(ptr);                         /* CRASH or corruption */
.fi
.SS Pool Exhaustion
IPC uses global pools shared by all actors:
.IP \(bu 2
.B HIVE_MAILBOX_ENTRY_POOL_SIZE
(256 default) \- mailbox entry headers
.IP \(bu 2
.B HIVE_MESSAGE_DATA_POOL_SIZE
(256 default) \- message payload buffers
.PP
.B "Default Behavior (pool_block = false):"
.PP
When pools are exhausted,
.BR hive_ipc_notify ()
and
.BR hive_ipc_notify_ex ()
return
.B HIVE_ERR_NOMEM
immediately. They do
.B not
block or drop messages. Implement backoff-retry:
.PP
.nf
#define MSG_DATA 1  /* Application-defined message type */
hive_status_t s = hive_ipc_notify(target, MSG_DATA, data, len);
if (s.code == HIVE_ERR_NOMEM) {
    hive_message_t msg;
    hive_ipc_recv(&msg, 10);  /* Backoff 10ms */
    /* Retry or handle failure */
}
.fi
.PP
.B "Blocking Behavior (pool_block = true):"
.PP
When
.I pool_block
is enabled (via spawn configuration or runtime API), notify/request operations will
.B yield
(block) when pools are exhausted, waiting until pool space becomes available.
The actor is added to a priority-ordered wait queue and woken when another
actor frees a pool entry.
.PP
Enable at spawn time via
.IR hive_actor_config_t :
.PP
.nf
hive_actor_config_t cfg = HIVE_ACTOR_CONFIG_DEFAULT;
cfg.pool_block = true;
hive_spawn(my_fn, NULL, NULL, &cfg, &id);
.fi
.PP
Or override at runtime within the actor:
.PP
.nf
hive_pool_set_block(HIVE_POOL_BLOCK);   /* Enable blocking */
hive_pool_set_block(HIVE_POOL_NO_BLOCK); /* Disable blocking */
hive_pool_set_block(HIVE_POOL_DEFAULT);  /* Restore spawn default */
.fi
.PP
.BR hive_pool_get_block ()
returns the current effective setting (true if blocking enabled).
.PP
.B "Warning:"
Blocking on pool exhaustion can lead to deadlock if all actors block without
any actor freeing pool entries. Use with care and ensure receivers process
messages promptly.
.PP
.B "Reserved System Entries:"
.br
The runtime reserves
.B HIVE_RESERVED_SYSTEM_ENTRIES
(default: 16) pool entries for system messages (TIMER and EXIT). User messages
cannot use these reserved entries, but timers and exit notifications can
always be delivered even under pool exhaustion. This ensures critical runtime
events are never blocked by user message pressure.
.SS Target Death During Request
.BR hive_ipc_request ()
automatically detects target death by setting up a temporary monitor. If the
target dies before replying, the function returns
.B HIVE_ERR_CLOSED
immediately (no need to wait for timeout). This allows clean error handling:
.PP
.nf
hive_status_t s = hive_ipc_request(target, &req, sizeof(req), &reply, 5000);
if (s.code == HIVE_ERR_CLOSED) {
    /* Target died before replying */
} else if (s.code == HIVE_ERR_TIMEOUT) {
    /* Target alive but did not reply in time */
}
.fi
.SS Selective Receive Performance
.BR hive_ipc_recv_match ()
scans the mailbox linearly. With deep mailboxes (100+ messages), this becomes
expensive. Keep mailboxes shallow by:
.IP \(bu 2
Processing messages promptly
.IP \(bu 2
Using
.BR hive_ipc_request ()
which provides natural backpressure
.IP \(bu 2
Avoiding patterns that queue many messages
.SS Embedded Considerations
.IP \(bu 2
Maximum message payload: 250 bytes (configurable via HIVE_MAX_MESSAGE_SIZE - 6 byte header)
.IP \(bu 2
Zero heap allocation in IPC operations
.IP \(bu 2
O(1) allocation from static pools
.IP \(bu 2
Deterministic memory usage suitable for certification
.SH EXAMPLE
.nf
#include <hive_runtime.h>
#include <hive_ipc.h>
#include <stdio.h>

typedef struct { int x, y; } point_t;
#define MSG_ADD_POINTS 1  /* Application-defined message type */

void server(void *arg, const hive_spawn_info_t *siblings,
            size_t sibling_count) {
    while (true) {
        hive_message_t msg;
        hive_ipc_recv_match(HIVE_SENDER_ANY, HIVE_MSG_REQUEST,
                            MSG_ADD_POINTS, &msg, -1);
        point_t *p = (point_t *)msg.data;
        int sum = p->x + p->y;
        hive_ipc_reply(&msg, &sum, sizeof(sum));
    }
}

void client(void *arg, const hive_spawn_info_t *siblings,
            size_t sibling_count) {
    hive_actor_id_t server_id = *(hive_actor_id_t *)arg;

    point_t req = {.x = 10, .y = 20};
    hive_message_t reply;

    hive_status_t s = hive_ipc_request(server_id, MSG_ADD_POINTS,
                                       &req, sizeof(req), &reply, 5000);
    if (HIVE_FAILED(s)) {
        printf("Request failed: %s\\n", HIVE_ERR_STR(s));
    } else {
        int *result = (int *)reply.data;
        printf("Result: %d\\n", *result);
    }

    return;
}
.fi
.SS Implementation Note
The receive functions
.BR hive_ipc_recv ()
and
.BR hive_ipc_recv_match ()
are implemented as thin wrappers around
.BR hive_select (3),
the unified event waiting primitive.
.SH SEE ALSO
.BR hive_init (3),
.BR hive_spawn (3),
.BR hive_link (3),
.BR hive_timer (3),
.BR hive_types (3),
.BR hive_select (3)
