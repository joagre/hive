.\" Man page for file I/O functions
.TH HIVE_FILE 3 "January 2026" "Hive 1.0" "Actor Runtime Manual"
.SH NAME
hive_file_open, hive_file_close, hive_file_read, hive_file_pread, hive_file_write, hive_file_pwrite, hive_file_sync, hive_file_mount_available \- synchronous file I/O
.SH SYNOPSIS
.nf
.B #include <hive_file.h>
.PP
.BI "hive_status_t hive_file_open(const char *" path ", int " flags ", int " mode ", int *" out ");"
.BI "hive_status_t hive_file_close(int " fd ");"
.BI "hive_status_t hive_file_read(int " fd ", void *" buf ", size_t " len ", size_t *" bytes_read ");"
.BI "hive_status_t hive_file_pread(int " fd ", void *" buf ", size_t " len ", size_t " offset ", size_t *" bytes_read ");"
.BI "hive_status_t hive_file_write(int " fd ", const void *" buf ", size_t " len ", size_t *" bytes_written ");"
.BI "hive_status_t hive_file_pwrite(int " fd ", const void *" buf ", size_t " len ", size_t " offset ", size_t *" bytes_written ");"
.BI "hive_status_t hive_file_sync(int " fd ");"
.BI "hive_status_t hive_file_mount_available(const char *" path ");"
.fi
.SH DESCRIPTION
These functions provide synchronous file I/O for actors.
.B WARNING:
File I/O is blocking and stalls the entire scheduler. On embedded systems with
fast filesystems (FATFS, littlefs), operations complete quickly (<1ms typically).
On Linux, regular files cannot use epoll, so blocking is unavoidable.
.SS Opening and Closing Files
.BR hive_file_open ()
opens the file at
.I path
with the specified
.I flags
and
.IR mode .
The file descriptor is stored in
.IR out .
.PP
The
.I flags
parameter uses platform-independent HIVE_O_* flags for cross-platform compatibility:
.TP
.B HIVE_O_RDONLY
Open for reading only.
.TP
.B HIVE_O_WRONLY
Open for writing only.
.TP
.B HIVE_O_RDWR
Open for reading and writing.
.TP
.B HIVE_O_CREAT
Create file if it does not exist (requires
.IR mode ).
.TP
.B HIVE_O_TRUNC
Truncate file to zero length if it exists. On STM32, this erases the flash sector.
.TP
.B HIVE_O_APPEND
Writes append to end of file.
.PP
The
.I mode
parameter specifies permissions for created files (e.g., 0644).
.PP
.BR hive_file_close ()
closes the file descriptor.
.SS Reading Files
.BR hive_file_read ()
reads up to
.I len
bytes from the current file position into
.IR buf .
The actual number of bytes read is stored in
.IR bytes_read .
A return of 0 bytes indicates end-of-file.
.PP
.BR hive_file_pread ()
reads at a specific
.I offset
without changing the file position (positional read). Useful for random access
and concurrent reads from the same file descriptor.
.SS Writing Files
.BR hive_file_write ()
writes up to
.I len
bytes from
.I buf
to the file. The actual number of bytes written is stored in
.IR bytes_written .
.PP
.BR hive_file_pwrite ()
writes at a specific
.I offset
without changing the file position (positional write).
.SS Syncing Files
.BR hive_file_sync ()
flushes the file's data and metadata to disk. This ensures durability after a
crash but is slow (may take tens of milliseconds on flash media).
.SS Checking Mount Availability
.BR hive_file_mount_available ()
checks if the mount point for
.I path
exists and is ready for I/O. This is useful for checking SD card presence
before attempting to open files.
.PP
.B Returns:
.IP \(bu 2
.B HIVE_OK
\- Mount exists and backend is ready
.IP \(bu 2
.B HIVE_ERR_INVALID
\- No mount for path
.IP \(bu 2
.B HIVE_ERR_IO
\- Mount exists but backend unavailable (e.g., SD card not inserted)
.PP
.B Example:
.PP
.nf
if (HIVE_SUCCEEDED(hive_file_mount_available("/sd"))) {
    hive_file_open("/sd/flight.bin", HIVE_O_WRONLY | HIVE_O_CREAT, 0, &fd);
} else {
    hive_file_open("/log", HIVE_O_WRONLY | HIVE_O_TRUNC, 0, &fd);
}
.fi
.SH RETURN VALUE
All functions return an
.I hive_status_t
structure. On success,
.I status.code
is
.BR HIVE_OK .
For read operations, 0 bytes read indicates end-of-file (not an error).
.SH ERRORS
.TP
.B HIVE_ERR_INVALID
NULL argument or file I/O subsystem not initialized.
.TP
.B HIVE_ERR_IO
POSIX I/O error (errno-based message: "No such file", "Permission denied", etc.).
.SH NOTES
.SS Minimal by Design
The file API is intentionally minimal - a cross-platform abstraction designed
for embedded constraints. It provides only basic operations that work on both
Linux and bare-metal embedded targets.
.PP
.B Intentionally omitted:
.IP \(bu 2
seek/lseek (use pread/pwrite instead)
.IP \(bu 2
stat/fstat (no file metadata)
.IP \(bu 2
readdir/opendir (no directory listing)
.IP \(bu 2
mkdir/rmdir/unlink (no file or directory management)
.IP \(bu 2
truncate, rename, chmod, mmap
.PP
These omissions reflect the lowest common denominator across platforms. On
embedded targets with flash-backed virtual files, many of these operations are
either impossible or would require complex emulation. The API provides what can
be implemented efficiently on resource-constrained targets.
.SS Blocking Behavior (Critical)
File I/O is
.B completely synchronous
and blocks the scheduler. Unlike TCP which integrates with epoll, file
operations cannot be made non-blocking on Linux (regular files ignore O_NONBLOCK).
.PP
While a file operation is in progress:
.IP \(bu 2
.B All other actors are blocked
.IP \(bu 2
Timers may fire late
.IP \(bu 2
TCP is delayed
.SS Safety-Critical Usage
For autopilot and other safety-critical applications, restrict file I/O to:
.IP \(bu 2
.B Initialization:
Load configuration files at startup before flight
.IP \(bu 2
.B Shutdown:
Save state or logs after flight
.IP \(bu 2
.B Non-critical phases:
Ground operations, pre-flight checks
.PP
.B Never use file I/O in flight-critical code paths.
.SS STM32 Flash File Implementation
On STM32, file I/O uses flash-backed virtual files with a ring buffer for efficiency:
.IP \(bu 2
Virtual file paths map to flash sectors (board-defined via -D flags, e.g.,
.B /log
maps to Sector 5 on Crazyflie 2.1+)
.IP \(bu 2
.BR hive_file_write ()
pushes to a RAM ring buffer (fast path). If the buffer is full, write blocks to flush
data to flash before continuing. This ensures no data loss.
.IP \(bu 2
.BR hive_file_sync ()
drains the ring buffer to flash (blocking, call periodically from a dedicated actor)
.IP \(bu 2
.B HIVE_O_TRUNC
erases the flash sector (blocks 1-4 seconds for 128KB sectors)
.PP
.B STM32 Flag Restrictions:
.IP \(bu 2
.B HIVE_O_RDWR
is rejected \- use
.B HIVE_O_RDONLY
or
.B HIVE_O_WRONLY
.IP \(bu 2
.B HIVE_O_WRONLY
requires
.B HIVE_O_TRUNC
(flash must be erased before writing)
.IP \(bu 2
.B HIVE_O_CREAT
and
.B HIVE_O_APPEND
are silently ignored
.PP
.B STM32 API Restrictions:
.IP \(bu 2
.BR hive_file_read ()
returns error \- use
.BR hive_file_pread ()
for direct flash reads
.IP \(bu 2
.BR hive_file_pwrite ()
returns error (ring buffer doesn't support random writes)
.IP \(bu 2
Only one file can be opened for writing at a time
.PP
Board configuration via -D flags in Makefile (each virtual file is optional):
.PP
.nf
# /log virtual file (for flight logging)
CFLAGS += -DHIVE_VFILE_LOG_BASE=0x08020000
CFLAGS += -DHIVE_VFILE_LOG_SIZE=131072
CFLAGS += -DHIVE_VFILE_LOG_SECTOR=5
# /config virtual file (optional, for calibration)
# CFLAGS += -DHIVE_VFILE_CONFIG_BASE=...
.fi
.PP
Ring buffer defaults (hive_static_config.h):
.PP
.nf
HIVE_FILE_RING_SIZE   = 8 KB
HIVE_FILE_BLOCK_SIZE  = 256 bytes
.fi
.SS STM32 SD Card Support (Optional)
When built with
.BR ENABLE_SD=1 ,
the runtime supports SD cards via SPI using the FatFS library. SD card files
are accessed through the
.B /sd
mount point.
.PP
.B SD Card Characteristics:
.IP \(bu 2
Full FatFS filesystem support (FAT12/16/32, exFAT)
.IP \(bu 2
Standard file operations work as expected (read, write, seek)
.IP \(bu 2
.B HIVE_O_RDWR
is supported (unlike flash virtual files)
.IP \(bu 2
No
.B HIVE_O_TRUNC
requirement for writes
.IP \(bu 2
Multiple files can be open simultaneously (up to
.BR HIVE_MAX_SD_FILES )
.PP
.B Example:
.PP
.nf
int fd;
hive_file_open("/sd/flight_log.bin", HIVE_O_WRONLY | HIVE_O_CREAT, 0644, &fd);
hive_file_write(fd, data, sizeof(data), &written);
hive_file_close(fd);
.fi
.PP
.B Porting:
Each board must implement
.B spi_ll_sd.c
with board-specific SPI pin configuration. See
.I src/hal/stm32/spi_ll.h
for the required interface.
.PP
.B SD Card Limitations:
.IP \(bu 2
.B No hot-plug detection
\- Card presence is checked at initialization only. If the card is removed
during operation, subsequent I/O fails with
.BR HIVE_ERR_IO .
.IP \(bu 2
.B No automatic directory creation
\-
.BR hive_file_open ()
with
.B HIVE_O_CREAT
does not create parent directories. Use flat file paths like
.IR /sd/flight_001.bin .
.IP \(bu 2
.B No file listing API
\- There is no
.BR readdir ()
equivalent. Use sequential filenames for logging.
.SS Partial Reads/Writes
Read and write operations may transfer fewer bytes than requested. Always check
the
.I bytes_read
or
.I bytes_written
output and loop if needed:
.PP
.nf
size_t total = 0;
while (total < len) {
    size_t n;
    hive_status_t s = hive_file_write(fd, buf + total, len - total, &n);
    if (HIVE_FAILED(s)) break;
    if (n == 0) break;  /* Disk full */
    total += n;
}
.fi
.SS File Descriptor Lifecycle
File descriptors from
.BR hive_file_open ()
must be closed with
.BR hive_file_close ()
when done. Unlike sockets, there is no automatic cleanup when an actor dies.
.SS No Heap Allocation
All file operations use POSIX syscalls directly with no heap allocation.
.SH EXAMPLE
.SS Configuration File
.nf
#include <hive_runtime.h>
#include <hive_file.h>
#include <stdio.h>
#include <string.h>

typedef struct {
    float pid_p, pid_i, pid_d;
    uint16_t refresh_rate_hz;
} config_t;

/* Load config at startup (before hive_run) */
hive_status_t load_config(config_t *cfg) {
    int fd;
    hive_status_t s = hive_file_open("/var/lib/pilot/config.bin",
                                   HIVE_O_RDONLY, 0, &fd);
    if (HIVE_FAILED(s)) {
        printf("Config not found, using defaults\\n");
        cfg->pid_p = 1.0f;
        cfg->pid_i = 0.1f;
        cfg->pid_d = 0.01f;
        cfg->refresh_rate_hz = 400;
        return HIVE_SUCCESS;
    }

    size_t n;
    s = hive_file_read(fd, cfg, sizeof(*cfg), &n);
    hive_file_close(fd);

    if (HIVE_FAILED(s) || n != sizeof(*cfg)) {
        return HIVE_ERROR(HIVE_ERR_IO, "Config read failed");
    }

    return HIVE_SUCCESS;
}
.fi
.SS Flight Data Recording (STM32)
.nf
#include <hive_runtime.h>
#include <hive_file.h>

/* Logger actor runs at LOW priority */
void logger_actor(void *arg, const hive_spawn_info_t *siblings,
                  size_t sibling_count) {

    /* Open and erase flash log region (blocks 1-4 seconds) */
    int fd;
    hive_file_open("/log", HIVE_O_WRONLY | HIVE_O_TRUNC, 0, &fd);

    while (flight_active) {
        /* Periodically sync ring buffer to flash */
        hive_sleep(100000);  /* 100ms */
        hive_file_sync(fd);
    }

    hive_file_close(fd);
    hive_exit();
}

/* Flight actor pushes data (O(1), never blocks) */
void flight_actor(void *arg, const hive_spawn_info_t *siblings,
                  size_t sibling_count) {
    int log_fd = *(int *)arg;

    while (running) {
        flight_data_t data;
        get_current_flight_data(&data);

        size_t n;
        /* Push to ring buffer - fast, may partial write if full */
        hive_file_write(log_fd, &data, sizeof(data), &n);

        hive_sleep(2000);  /* 2ms control loop */
    }
    hive_exit();
}

int main(void) {
    hive_init();

    /* Spawn logger at LOW priority */
    actor_id_t logger;
    hive_actor_config_t cfg = {.priority = 3};  /* LOW */
    hive_spawn(logger_actor, NULL, NULL, &cfg, &logger);

    hive_run();
    hive_cleanup();
    return 0;
}
.fi
.SS Positional I/O
.nf
/* Random access to indexed data file */
typedef struct {
    uint32_t timestamp;
    float value;
} record_t;

hive_status_t read_record(int fd, size_t index, record_t *rec) {
    size_t offset = index * sizeof(record_t);
    size_t n;
    hive_status_t s = hive_file_pread(fd, rec, sizeof(*rec), offset, &n);
    if (HIVE_FAILED(s)) return s;
    if (n != sizeof(*rec)) {
        return HIVE_ERROR(HIVE_ERR_IO, "Short read");
    }
    return HIVE_SUCCESS;
}
.fi
.SH NOTES ON STM32 WRITE BEHAVIOR
On STM32, the file I/O implementation uses a
.B buffered ring buffer
for efficiency. Most writes complete immediately by copying to the ring buffer.
When the buffer fills up, write blocks to flush data to flash before continuing.
.PP
This ensures the same no-data-loss semantics as Linux while providing fast writes
in the common case. The behavior is:
.IP \(bu 2
Fast path: Ring buffer has space \- write completes immediately
.IP \(bu 2
Slow path: Ring buffer full \- write blocks to flush to flash
.PP
.B Recommendation:
Call
.BR hive_file_sync ()
periodically (e.g., every 4 seconds from a dedicated actor) to ensure data is
committed to flash before unexpected power loss.
.SH SEE ALSO
.BR hive_tcp (3),
.BR hive_spawn (3),
.BR open (2),
.BR read (2),
.BR write (2),
.BR pread (2),
.BR pwrite (2),
.BR fsync (2)
