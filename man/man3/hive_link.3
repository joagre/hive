.\" Man page for linking and monitoring functions
.TH HIVE_LINK 3 "January 2026" "Hive 1.0" "Actor Runtime Manual"
.SH NAME
hive_link, hive_unlink, hive_monitor, hive_demonitor, hive_msg_is_exit, hive_decode_exit, hive_exit_reason_str \- actor linking and monitoring
.SH SYNOPSIS
.nf
.B #include <hive_link.h>
.PP
.BI "hive_status_t hive_link(actor_id_t " target ");"
.BI "hive_status_t hive_unlink(actor_id_t " target ");"
.BI "hive_status_t hive_monitor(actor_id_t " target ", uint32_t *" out ");"
.BI "hive_status_t hive_demonitor(uint32_t " id ");"
.BI "bool hive_msg_is_exit(const hive_message_t *" msg ");"
.BI "hive_status_t hive_decode_exit(const hive_message_t *" msg ", hive_exit_msg_t *" out ");"
.BI "const char *hive_exit_reason_str(hive_exit_reason_t " reason ");"
.fi
.SH DESCRIPTION
These functions enable actors to be notified when other actors die, supporting
fault-tolerant monitoring patterns.
.SS Bidirectional Links
.BR hive_link ()
creates a bidirectional link between the calling actor and
.IR target .
If either actor dies, the other receives an EXIT message. Links are symmetric:
if A links to B, both A and B receive notifications when the other dies.
.PP
.BR hive_unlink ()
removes a previously established link. Both directions are removed.
.SS Unidirectional Monitors
.BR hive_monitor ()
creates a unidirectional monitor. The calling actor receives an EXIT message
when
.I target
dies, but not vice versa. The monitor ID is stored in
.IR out .
Multiple monitors can be created for the same target.
.PP
.BR hive_demonitor ()
cancels a monitor using the ID returned by
.BR hive_monitor ().
.SS Exit Messages
When a linked or monitored actor dies, an EXIT message is delivered to the
mailbox with class
.BR HIVE_MSG_EXIT .
The payload is:
.PP
.nf
typedef struct {
    actor_id_t         actor;   /* ID of the actor that died */
    hive_exit_reason_t reason;  /* Why the actor exited */
    uint32_t         monitor_id; /* 0 = link, non-zero = monitor ID */
} hive_exit_msg_t;
.fi
.PP
The
.I monitor_id
field distinguishes exit notifications from links vs monitors:
.IP \(bu 2
.B monitor_id == 0
\- notification came from a bidirectional link
.IP \(bu 2
.B monitor_id != 0
\- notification came from a monitor; value matches the ID
returned by
.BR hive_monitor ()
.PP
Use
.BR hive_decode_exit ()
to extract the exit information:
.PP
.nf
if (hive_msg_is_exit(&msg)) {
    hive_exit_msg_t info;
    hive_decode_exit(&msg, &info);
    if (info.monitor_id == 0) {
        printf("Linked actor %u died\\n", info.actor);
    } else {
        printf("Monitored actor %u died (id=%u)\\n",
               info.actor, info.monitor_id);
    }
}
.fi
.SS Exit Reasons
.TP
.B HIVE_EXIT_NORMAL
Actor called
.BR hive_exit ().
.TP
.B HIVE_EXIT_CRASH
Actor function returned without calling
.BR hive_exit ().
.TP
.B HIVE_EXIT_CRASH_STACK
Stack overflow detected (reserved for future hardware-based detection).
.TP
.B HIVE_EXIT_KILLED
Actor was killed externally (reserved for future use).
.SS Helper Functions
.BR hive_msg_is_exit ()
returns true if
.I msg
has class
.BR HIVE_MSG_EXIT .
.PP
.BR hive_decode_exit ()
decodes an exit message, copying the exit information into
.IR out .
Returns
.B HIVE_SUCCESS
on success, or
.B HIVE_ERR_INVALID
if the message is not an exit message.
.PP
.BR hive_exit_reason_str ()
returns a human-readable string for the exit reason:
"NORMAL", "CRASH", "STACK_OVERFLOW", or "KILLED".
.SH RETURN VALUE
.BR hive_link (),
.BR hive_unlink (),
.BR hive_monitor (),
.BR hive_demonitor (),
and
.BR hive_decode_exit ()
return an
.I hive_status_t
structure.
.PP
.BR hive_msg_is_exit ()
returns true if the message is an exit notification.
.PP
.BR hive_exit_reason_str ()
returns a constant string describing the exit reason.
.SH ERRORS
.TP
.B HIVE_ERR_INVALID
Cannot link/monitor self, target actor is dead or invalid, not linked to
target (for remove), or monitor ID not found (for cancel).
.TP
.B HIVE_ERR_NOMEM
Link or monitor pool exhausted (HIVE_LINK_ENTRY_POOL_SIZE or
HIVE_MONITOR_ENTRY_POOL_SIZE).
.SH NOTES
.SS Links vs Monitors
Use
.B links
for peer relationships where both parties need to know about failures (e.g.,
two cooperating actors). Use
.B monitors
for one-way monitoring where only the monitoring actor needs notifications
(e.g., manager watching workers).
.SS Worker Monitoring Pattern
The common worker monitoring pattern:
.IP 1. 3
Manager spawns workers
.IP 2. 3
Manager monitors each worker
.IP 3. 3
When a worker dies, manager receives EXIT message
.IP 4. 3
Manager decides whether to restart worker, escalate, or ignore
.SS Multiple Links/Monitors
.IP \(bu 2
An actor can link to multiple other actors
.IP \(bu 2
An actor can be linked to by multiple other actors
.IP \(bu 2
Multiple monitors can exist for the same target (each has unique ID)
.IP \(bu 2
Linking to an already-linked actor returns an error
.SS Automatic Cleanup
When an actor dies:
.IP \(bu 2
All its links are removed (notifications sent to linked actors)
.IP \(bu 2
All monitors watching it receive notifications
.IP \(bu 2
All monitors it created are cancelled
.SS Pool Limits
Default pool sizes (configurable in hive_static_config.h):
.IP \(bu 2
.B HIVE_LINK_ENTRY_POOL_SIZE
\- 128 link entries
.IP \(bu 2
.B HIVE_MONITOR_ENTRY_POOL_SIZE
\- 128 monitor entries
.SS Embedded Considerations
.IP \(bu 2
O(1) allocation from static pools
.IP \(bu 2
O(n) scan when actor dies to notify all linked/monitoring actors
.IP \(bu 2
No heap allocation
.IP \(bu 2
Deterministic behavior suitable for safety-critical systems
.SH EXAMPLE
.SS Worker Monitoring Pattern
.nf
#include <hive_runtime.h>
#include <hive_link.h>
#include <hive_ipc.h>
#include <stdio.h>

void worker(void *arg, const hive_spawn_info_t *siblings,
            size_t sibling_count) {
    int id = *(int *)arg;
    printf("Worker %d started\\n", id);
    /* Simulate work then exit normally */
    hive_exit();
}

void manager(void *arg, const hive_spawn_info_t *siblings,
             size_t sibling_count) {
    int worker_ids[3] = {1, 2, 3};
    uint32_t monitors[3];

    /* Spawn and monitor workers */
    for (int i = 0; i < 3; i++) {
        actor_id_t w;
        hive_spawn(worker, NULL, &worker_ids[i], NULL, &w);
        hive_monitor(w, &monitors[i]);
        printf("Manager: monitoring worker %u\\n", w);
    }

    /* Wait for workers to exit */
    int exited = 0;
    while (exited < 3) {
        hive_message_t msg;
        hive_ipc_recv(&msg, -1);

        if (hive_msg_is_exit(&msg)) {
            hive_exit_msg_t info;
            hive_decode_exit(&msg, &info);
            printf("Manager: worker %u exited (%s)\\n",
                   info.actor, hive_exit_reason_str(info.reason));
            exited++;

            if (info.reason != HIVE_EXIT_NORMAL) {
                /* Could restart worker here */
                printf("Manager: would restart crashed worker\\n");
            }
        }
    }

    printf("Manager: all workers done\\n");
    hive_exit();
}

int main(void) {
    hive_init();
    actor_id_t mgr;
    hive_spawn(manager, NULL, NULL, NULL, &mgr);
    hive_run();
    hive_cleanup();
    return 0;
}
.fi
.SH SEE ALSO
.BR hive_spawn (3),
.BR hive_ipc (3),
.BR hive_supervisor (3),
.BR hive_types (3)
